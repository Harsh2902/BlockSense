<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BlockSense</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
  <style>
    :root {
      --bg-dark: #0d1117; --card-dark: #161b22; --text-dark: #fff;
      --bg-light: #f8f9fa; --card-light: #fff; --text-light: #000;
      --highlight-dark: #58a6ff; --highlight-light: #007bff;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background-color: var(--bg-dark);
      transition: all 0.3s;
      padding-top: 70px; /* Add padding for the fixed header */
    }

    .light-mode {
      background-color: var(--bg-light);
      color: var(--text-light) !important; /* Ensure all body text is light text color */
    }

    /* Ensure all primary text elements adhere to theme */
    body,
    h1, h2, h3, h4, h5, h6,
    p,
    label,
    span,
    strong,
    div { /* Apply to div to catch unclassified text containers */
      color: var(--text-dark);
    }

    .light-mode body,
    .light-mode h1, .light-mode h2, .light-mode h3, .light-mode h4, .light-mode h5, .light-mode h6,
    .light-mode p,
    .light-mode label,
    .light-mode span,
    .light-mode strong,
    .light-mode div {
      color: var(--text-light);
    }


    .card {
      border-radius: 12px;
      background-color: var(--card-dark);
      padding: 20px;
      margin-bottom: 20px;
      transition: background-color 0.3s;
    }

    .light-mode .card {
      background-color: var(--card-light);
    }

    textarea, input, pre, code {
      width: 100%;
      border-radius: 8px;
      padding: 10px;
      border: 1px solid #444;
      background-color: #0d1117;
      color: white; /* Explicitly white for dark mode */
    }

    .light-mode textarea, .light-mode input, .light-mode pre, .light-mode code {
      background-color: #fff;
      color: #000; /* Explicitly black for light mode */
      border: 1px solid #ccc;
    }

    .output-box {
      border-radius:10px;
      padding:20px;
      margin-top:15px;
      overflow-x: auto;
    }

    pre code {
      white-space: pre-wrap;
      word-break: break-word;
    }

    .spinner-border {
      width: 1rem;
      height: 1rem;
      display: none;
      margin-left: 10px;
    }

    .loader-text {
      font-style: italic;
      font-size: 0.9rem;
      color: #aaa;
      margin-top: 0.5rem;
      display: none;
    }

    .light-mode .loader-text {
      color: #555;
    }

    #blockdagGraph {
      height: 400px;
      border: 1px solid #333;
      border-radius: 8px;
      background-color: #1e1e1e;
    }

    .header-buttons {
      position: fixed;
      top: 10px;
      right: 20px;
      z-index: 999;
      display: flex;
      gap: 10px;
      align-items: center; /* Align items vertically */
      background-color: var(--bg-dark); /* Ensure background for fixed header */
      padding: 10px 20px; /* Add some padding to the fixed header area */
      border-radius: 8px; /* Optional: smooth corners */
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Optional: subtle shadow */
    }

    .light-mode .header-buttons {
        background-color: var(--bg-light); /* Light mode background */
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    /* Removed #walletStatus styling as the element is removed */
    /*
    #walletStatus {
        margin-right: 15px;
        font-size: 0.9em;
        color: #888;
    }
    .light-mode #walletStatus {
        color: #666;
    }
    */

    /* Modal specific styles for dark/light mode */
    .modal-content {
      background-color: var(--card-dark);
      border-radius: 12px;
    }

    .light-mode .modal-content {
      background-color: var(--card-light);
    }

    .modal-header, .modal-footer {
      border-color: #444; /* Dark mode border */
    }

    .light-mode .modal-header, .light-mode .modal-footer {
      border-color: #ccc; /* Light mode border */
    }

    .modal-header .btn-close {
      filter: invert(1); /* Ensure close button is visible in dark mode */
    }

    .light-mode .modal-header .btn-close {
      filter: invert(0); /* Ensure close button is visible in light mode */
    }

    /* Override Bootstrap's specific text colors within modal for theme adherence */
    .modal-content .text-danger,
    .modal-content .text-info,
    .modal-content .text-success,
    .modal-content .text-warning { /* Added text-warning here */
      color: var(--text-dark) !important; /* Override Bootstrap's fixed color for dark mode */
    }

    .light-mode .modal-content .text-danger,
    .light-mode .modal-content .text-info,
    .light-content .modal-content .text-success,
    .light-content .modal-content .text-warning { /* Added text-warning here */
      color: var(--text-light) !important; /* Override Bootstrap's fixed color for light mode */
    }

    /* Ensure specific elements in the chat response box also follow the theme */
    #chatResponse div, #chatResponse strong {
      color: var(--text-dark); /* Default for dark mode */
    }
    .light-mode #chatResponse div, .light-mode #chatResponse strong {
      color: var(--text-light); /* For light mode */
    }

    /* Added for wallet selection */
    .wallet-selection-group label {
        margin-right: 15px;
    }

    /* Custom styles for MetaMask button based on image */
    #connectMetaMaskBtn {
        width: 100%;
        padding: 10px 20px;
        font-size: 1.1rem;
        font-weight: bold;
        background-color: #007bff; /* Primary blue */
        border-color: #007bff;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2);
        transition: background-color 0.2s, box-shadow 0.2s;
    }

    #connectMetaMaskBtn:hover {
        background-color: #0056b3; /* Darker blue on hover */
        border-color: #0056b3;
        box-shadow: 0 6px 12px rgba(0, 123, 255, 0.3);
    }

    /* Style for the Connect Wallet button when a wallet is connected */
    #connectWalletBtn.connected {
        background-color: #28a745; /* Green color for connected state */
        border-color: #28a745;
        /* Removed cursor: default; to ensure it's still clickable */
    }
    #connectWalletBtn.connected:hover {
        background-color: #28a745; /* Keep green on hover */
        border-color: #28a745;
        box-shadow: 0 2px 4px rgba(0,123,255,0.2); /* Less pronounced shadow */
    }

    .or-separator {
        display: flex;
        align-items: center;
        text-align: center;
        margin: 20px 0;
        color: #777; /* Gray for "OR" */
    }

    .or-separator::before,
    .or-separator::after {
        content: '';
        flex: 1;
        border-bottom: 1px solid #444; /* Line color for dark mode */
    }

    .light-mode .or-separator::before,
    .light-mode .or-separator::after {
      border-bottom: 1px solid #ccc; /* Line color for light mode */
    }

    .or-separator:not(:empty)::before {
        margin-right: .25em;
    }

    .or-separator:not(:empty)::after {
        margin-left: .25em;
    }

    /* New style for theme toggle in light mode */
    .light-mode #themeToggle {
        background-color: black !important;
        color: white !important;
        border-color: black !important;
    }
  </style>
</head>

<body class="dark-mode">
  <div class="header-buttons">
    <!-- Removed <span id="walletStatus">Active Wallet: Not Connected</span> -->
    <button id="connectWalletBtn" class="btn btn-sm btn-outline-light">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-wallet" viewBox="0 0 16 16">
        <path d="M0 3a2 2 0 0 1 2-2h13.5a.5.5 0 0 1 0 1H2a1 1 0 0 0-1 1v8.5a1 1 0 0 0 1 1h12.5a.5.5 0 = 0 1 0 1H2a2 2 0 0 1-2-2z"/>
        <path d="M11.5 5a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5z"/>
      </svg>
      Connect Wallet
    </button>
    <button id="themeToggle" class="btn btn-sm btn-outline-light">‚òÄÔ∏è Light Mode</button>
  </div>
  <div class="container py-5">
    <h1 class="text-center mb-4 animate__animated animate__fadeInDown">üöÄ BlockSense</h1>

    <div class="card animate__animated animate__fadeInUp">
      <h4>üß† Explain Solidity Contract</h4>
      <form id="formContract">
        <textarea id="contract" rows="10" placeholder="Paste your Solidity code..." required></textarea>
        <div class="text-end mt-2">
          <button type="submit" class="btn btn-success">
            Explain üîç <span class="spinner-border spinner-border-sm"></span>
          </button>
          <div id="explainLoader" class="loader-text">üîÑ Processing contract...</div>
        </div>
      </form>
      <div class="output-box" id="explanationBox" style="display:none">
        <pre><code id="explanationCode" class="hljs"></code></pre>
      </div>
    </div>

    <div class="card animate__animated animate__fadeInUp">
      <h4>ü§ñ EVM Chatbot</h4>
      <form id="chatForm">
        <textarea id="chat_input" rows="3" placeholder="Say ‚Äòtransfer 0.1 ETH to 0x...‚Äô" required></textarea>
        <div class="text-end mt-2">
          <button type="submit" class="btn btn-info">
            Send <span class="spinner-border spinner-border-sm"></span>
          </button>
          <div id="chatLoader" class="loader-text">üí¨ AI is thinking...</div>
        </div>
      </form>
      <div class="output-box" id="chatResponse" style="display:none"></div>
    </div>

    <div class="card animate__animated animate__fadeInUp">
      <h4>üì¶ Deploy Contract</h4>
      <textarea id="deployAbi" rows="4" placeholder="Enter ABI as JSON..."></textarea>
      <textarea id="deployBytecode" rows="4" placeholder="Enter Bytecode..."></textarea>
      <div class="text-end mt-2">
        <button class="btn btn-warning" onclick="deployContract()">
          Deploy <span class="spinner-border spinner-border-sm" id="deploySpinner"></span>
        </button>
        <div id="deployLoader" class="loader-text">üöÄ Deploying contract...</div>
      </div>
      <div id="deployResult" class="output-box mt-2"></div>
    </div>

    <div class="card animate__animated animate__fadeInUp">
      <h4>üîß Interact with Contract</h4>
      <textarea id="interactAbi" rows="4" placeholder="Enter ABI as JSON..."></textarea>
      <input id="contractAddress" placeholder="Contract Address" />
      <input id="methodName" placeholder="Method Name" />
      <input id="methodArgs" placeholder="Arguments (comma-separated)" />
      <div class="text-end mt-2">
        <button class="btn btn-primary" onclick="interact()">
          Call <span class="spinner-border spinner-border-sm" id="interactSpinner"></span>
        </button>
        <div id="interactLoader" class="loader-text">‚öôÔ∏è Interacting with contract...</div>
      </div>
      <div id="interactResult" class="output-box mt-2"></div>
    </div>

    <div class="card animate__animated animate__fadeInUp">
      <h4>üåê BlockDAG Visualization</h4>
      <div id="blockdagGraph"></div>
    </div>
  </div>

  <div class="modal fade" id="walletConnectModal" tabindex="-1" aria-labelledby="walletConnectModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="walletConnectModalLabel">Connect Your Wallet</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p class="text-danger">
            <strong>Warning:</strong> For demonstration purposes, the private key input
            option sends your private key to the backend. In a real
            application, private keys should NEVER leave the client-side (e.g.,
            using MetaMask). Use with caution and only with test accounts.
            MetaMask connection is preferred and more more secure.
          </p>

          <button type="button" class="btn btn-info" id="connectMetaMaskBtn">Connect with MetaMask</button>

          <div class="or-separator">OR</div>

          <div class="mb-3">
            <label for="privateKeyInput" class="form-label">Private Key (for test accounts):</label>
            <input type="password" class="form-control" id="privateKeyInput" placeholder="Enter your private key (e.g., 0x...)">
          </div>
          <div class="mb-3">
            <label for="nodeUrlInput" class="form-label">EVM Node URL (e.g., http://127.0.0.1:8545 or https://sepolia.infura.io/v3/...):</label>
            <input type="text" class="form-control" id="nodeUrlInput" placeholder="Enter your EVM node URL">
          </div>
          <div class="mb-3">
            <label for="walletAddressInput" class="form-label">Active Wallet Address:</label>
            <input type="text" class="form-control" id="walletAddressInput" readonly placeholder="Not Connected">
          </div>
          <div id="walletConnectMessage" class="mt-3"></div>
          <button type="button" class="btn btn-primary" id="confirmConnectBtn">
            Connect Backend Wallet <span class="spinner-border spinner-border-sm" id="connectWalletSpinner"></span>
          </button>

          <hr>

          <h5>Active Transaction Wallet:</h5>
          <div class="wallet-selection-group">
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="radio" name="activeWallet" id="radioBackendWallet" value="backend">
              <label class="form-check-label" for="radioBackendWallet">Backend (Private Key)</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="radio" name="activeWallet" id="radioMetaMask" value="metamask" disabled>
              <label class="form-check-label" for="radioMetaMask">MetaMask (Not Connected)</label>
            </div>
          </div>

        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          <button type="button" class="btn btn-danger" id="disconnectWalletBtn">Disconnect All Wallets</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
    // Initialize Web3 for client-side address derivation (for privateKeyInput)
    const web3 = new Web3();

    // --- Theme Toggle Logic (Original) ---
    function applyTheme(mode) {
      document.body.classList.toggle('dark-mode', mode === 'dark');
      document.body.classList.toggle('light-mode', mode === 'light');
      document.getElementById('themeToggle').innerText = mode === 'light' ? 'üåô Dark Mode' : '‚òÄÔ∏è Light Mode';
      localStorage.setItem('theme', mode);

      const connectWalletBtn = document.getElementById('connectWalletBtn');
      connectWalletBtn.classList.remove('btn-outline-light', 'btn-outline-dark');
      if (mode === 'light') {
        connectWalletBtn.classList.add('btn-outline-dark');
      } else {
        connectWalletBtn.classList.add('btn-outline-light');
      }
      updateConnectWalletButtonStatus(); // Call to update button style based on theme change
    }

    document.getElementById('themeToggle').onclick = () => {
      const newMode = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
      applyTheme(newMode);
    };
    applyTheme(localStorage.getItem('theme') || 'dark'); // Apply theme on initial load


    // --- Wallet Selection Elements ---
    const radioBackendWallet = document.getElementById('radioBackendWallet');
    const radioMetaMask = document.getElementById('radioMetaMask');
    const connectWalletButtonHeader = document.getElementById('connectWalletBtn'); // Get the button in the header

    // --- Global Wallet State ---
    let backendWalletConnectedAddress = null; // Stores the address connected via private key (backend)
    let web3MetaMask; // Web3 instance connected to MetaMask provider
    let metaMaskConnectedAccount = null; // Stores MetaMask's currently selected account

    // --- Connect Wallet Modal Logic (Backend Private Key) ---
    const walletConnectModal = new bootstrap.Modal(document.getElementById('walletConnectModal'));
    const privateKeyInput = document.getElementById('privateKeyInput');
    const nodeUrlInput = document.getElementById('nodeUrlInput'); // New input for node URL
    const walletAddressInput = document.getElementById('walletAddressInput');
    const confirmConnectBtn = document.getElementById('confirmConnectBtn');
    const connectWalletSpinner = document.getElementById('connectWalletSpinner');
    const walletConnectMessage = document.getElementById('walletConnectMessage');
    // Removed walletStatusSpan as it's no longer needed in the header

    connectWalletButtonHeader.onclick = () => { // Event listener for the header button
      walletConnectMessage.innerHTML = ''; // Clear previous messages
      updateWalletRadioButtons(); // Ensure radio buttons and status are up-to-date
      walletConnectModal.show();
    };

    privateKeyInput.oninput = () => {
      const privateKey = privateKeyInput.value.trim();
      if (privateKey.startsWith('0x') && privateKey.length === 66) { // Basic check for 0x + 64 hex chars
        try {
          const account = web3.eth.accounts.privateKeyToAccount(privateKey);
          walletAddressInput.value = account.address;
          walletConnectMessage.innerHTML = '';
        } catch (error) {
          walletAddressInput.value = 'Invalid Key';
          walletConnectMessage.innerHTML = '<div class="text-danger">Invalid private key format.</div>';
        }
      } else {
        walletAddressInput.value = '';
        walletConnectMessage.innerHTML = '';
        if (privateKey.length > 0) {
            walletConnectMessage.innerHTML = '<div class="text-warning">Private key should start with "0x" and be 66 characters long.</div>';
        }
      }
    };

    confirmConnectBtn.onclick = async () => {
      const privateKey = privateKeyInput.value.trim();
      const nodeUrl = nodeUrlInput.value.trim(); // Get the node URL

      if (!privateKey) {
        walletConnectMessage.innerHTML = '<div class="text-danger">Please enter your private key.</div>';
        return;
      }
      if (!nodeUrl) {
        walletConnectMessage.innerHTML = '<div class="text-danger">Please enter your EVM Node URL.</div>';
        return;
      }

      connectWalletSpinner.style.display = 'inline-block';
      confirmConnectBtn.disabled = true;
      walletConnectMessage.innerHTML = '<div class="text-info">Connecting backend wallet...</div>';

      try {
        const res = await fetch('/set_wallet_config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ private_key: privateKey, node_url: nodeUrl }) // Send node URL
        });
        const data = await res.json();

        if (data.status === 'success') {
          backendWalletConnectedAddress = data.address; // Store for later use
          walletConnectMessage.innerHTML = `<div class="text-success">Backend Wallet Connected: ${data.address}</div>`;
          // Save credentials to localStorage on successful connection
          localStorage.setItem('backendPrivateKey', privateKey);
          localStorage.setItem('backendNodeUrl', nodeUrl);
          updateWalletRadioButtons(); // Update UI state after connection
          updateConnectWalletButtonStatus(); // Update the header button
          setTimeout(() => walletConnectModal.hide(), 1500);
        } else {
          backendWalletConnectedAddress = null; // Clear if connection fails
          walletConnectMessage.innerHTML = `<div class="text-danger">Error: ${data.message}</div>`;
          // Clear localStorage if connection fails
          localStorage.removeItem('backendPrivateKey');
          localStorage.removeItem('backendNodeUrl');
          updateWalletRadioButtons(); // Update UI state after failure
          updateConnectWalletButtonStatus(); // Update the header button
        }
      } catch (error) {
        backendWalletConnectedAddress = null; // Clear on network error
        walletConnectMessage.innerHTML = `<div class="text-danger">Network error: ${error.message}</div>`;
        // Clear localStorage on network error
        localStorage.removeItem('backendPrivateKey');
        localStorage.removeItem('backendNodeUrl');
        updateWalletRadioButtons(); // Update UI state after network error
        updateConnectWalletButtonStatus(); // Update the header button
      } finally {
        connectWalletSpinner.style.display = 'none';
        confirmConnectBtn.disabled = false;
      }
    };

    // --- MetaMask Wallet Logic (Client-Side for Transactions) ---
    const connectMetaMaskBtn = document.getElementById('connectMetaMaskBtn');

    // Function to update MetaMask's internal state and radio button
    const updateMetaMaskInternalState = async (accounts) => {
      if (accounts && accounts.length > 0) {
        metaMaskConnectedAccount = accounts[0];
        // Ensure web3MetaMask is initialized if accounts are found
        if (typeof window.ethereum !== 'undefined' && !web3MetaMask) {
          web3MetaMask = new Web3(window.ethereum);
        }

        if (typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask && web3MetaMask) {
          try {
            const balanceWei = await web3MetaMask.eth.getBalance(metaMaskConnectedAccount);
            const balanceEth = web3MetaMask.utils.fromWei(balanceWei, 'ether');
            console.log(`MetaMask Balance: ${parseFloat(balanceEth).toFixed(4)} ETH`);
            const currentChainId = await web3MetaMask.eth.getChainId();
            console.log(`MetaMask Chain ID: ${currentChainId}`);
          } catch (error) {
            console.error("Error fetching MetaMask details:", error);
          }
        }
      } else {
        // No accounts connected or accounts array is empty
        metaMaskConnectedAccount = null;
        web3MetaMask = null; // Clear web3MetaMask instance
      }
      updateWalletRadioButtons(); // Always update UI state after MetaMask internal state changes
      updateConnectWalletButtonStatus(); // Update the header button
    };

    // Function to initiate MetaMask connection (on button click)
    const connectMetaMask = async () => {
      if (typeof window.ethereum !== 'undefined') {
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          web3MetaMask = new Web3(window.ethereum); // Initialize web3MetaMask here as well
          updateMetaMaskInternalState(accounts);
        } catch (error) {
          console.error("User rejected connection or other MetaMask error:", error);
          alert('MetaMask connection failed or rejected: ' + error.message);
        }
      } else {
        // Mobile deep link logic
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const isMobile = /android|iphone|ipad|ipod|blackberry|windows phone/i.test(userAgent);

        if (isMobile) {
          // Use window.location.href directly as it provides the full, unencoded URL
          const metamaskDeepLink = `https://metamask.app.link/dapp/${window.location.href}`;

          console.log("Attempting MetaMask deep link:", metamaskDeepLink); // Log for debugging
          alert("MetaMask is not detected in this browser. Attempting to open in MetaMask mobile app...");
          window.open(metamaskDeepLink, '_blank'); // Open in new tab/app
        } else {
          // Desktop browser without MetaMask installed
          alert('MetaMask is not installed. Please install it to use this feature.');
        }
      }
    };

    connectMetaMaskBtn.addEventListener('click', connectMetaMask);

    // Listen for MetaMask accounts and chain changes proactively if ethereum object is present
    if (typeof window.ethereum !== 'undefined') {
      window.ethereum.on('accountsChanged', (accounts) => {
        console.log("MetaMask accounts changed:", accounts);
        updateMetaMaskInternalState(accounts);
      });

      window.ethereum.on('chainChanged', (chainId) => {
        console.log("MetaMask chain changed:", chainId);
        // Re-fetch accounts to ensure status update after chain change
        window.ethereum.request({ method: 'eth_accounts' })
          .then(updateMetaMaskInternalState)
          .catch(error => console.error("Error after chain changed:", error));
      });
    }

    // Function to update the state of the wallet radio buttons (inside modal)
    function updateWalletRadioButtons() {
        // Update MetaMask radio button and button state
        if (metaMaskConnectedAccount) {
            radioMetaMask.disabled = false;
            radioMetaMask.parentElement.querySelector('label').textContent = `MetaMask (${metaMaskConnectedAccount.substring(0, 6)}...)`;
            connectMetaMaskBtn.textContent = 'MetaMask Connected';
            connectMetaMaskBtn.classList.remove('btn-info');
            connectMetaMaskBtn.classList.add('btn-success');
            connectMetaMaskBtn.disabled = true; // Disable if already connected
        } else {
            radioMetaMask.disabled = true;
            radioMetaMask.parentElement.querySelector('label').textContent = 'MetaMask (Not Connected)';
            connectMetaMaskBtn.textContent = 'Connect with MetaMask';
            connectMetaMaskBtn.classList.remove('btn-success');
            connectMetaMaskBtn.classList.add('btn-info');
            connectMetaMaskBtn.disabled = false; // Enable if not connected
        }

        // Update Backend radio button state
        if (backendWalletConnectedAddress) {
            radioBackendWallet.disabled = false;
            radioBackendWallet.parentElement.querySelector('label').textContent = `Backend (${backendWalletConnectedAddress.substring(0, 6)}...)`;
        } else {
            radioBackendWallet.disabled = true;
            radioBackendWallet.parentElement.querySelector('label').textContent = 'Backend (Private Key)';
        }

        // Determine which wallet is actively selected for the radio buttons
        if (metaMaskConnectedAccount) {
            radioMetaMask.checked = true;
            radioBackendWallet.checked = false;
        } else if (backendWalletConnectedAddress) {
            radioBackendWallet.checked = true;
            radioMetaMask.checked = false;
        } else {
            radioBackendWallet.checked = false;
            radioMetaMask.checked = false;
        }
    }

    // New function to update the header's Connect Wallet button appearance
    function updateConnectWalletButtonStatus() {
        if (backendWalletConnectedAddress || metaMaskConnectedAccount) {
            connectWalletButtonHeader.textContent = "Wallet Connected";
            connectWalletButtonHeader.classList.remove('btn-outline-light', 'btn-outline-dark');
            connectWalletButtonHeader.classList.add('btn-success', 'connected'); // Add 'connected' class for styling
            // connectWalletButtonHeader.disabled = true; // REMOVED: Keep the button enabled to open modal
        } else {
            connectWalletButtonHeader.textContent = "Connect Wallet";
            connectWalletButtonHeader.classList.remove('btn-success', 'connected');
            // Re-apply correct outline color based on current theme
            const currentTheme = localStorage.getItem('theme') || 'dark';
            if (currentTheme === 'light') {
                connectWalletButtonHeader.classList.add('btn-outline-dark');
            } else {
                connectWalletButtonHeader.classList.add('btn-outline-light');
            }
            connectWalletButtonHeader.disabled = false; // Ensure button is enabled
        }
    }


    // --- Disconnect Wallet Button Logic ---
    const disconnectWalletBtn = document.getElementById('disconnectWalletBtn');

    disconnectWalletBtn.onclick = async () => {
        // Disconnect Backend Wallet (clear state locally and via backend API)
        try {
            const res = await fetch('/clear_wallet_config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            const data = await res.json();
            if (data.status === 'success') {
                console.log("Backend wallet disconnected via API.");
                walletConnectMessage.innerHTML = '<div class="text-success">Backend wallet disconnected.</div>';
            } else {
                console.error("Error clearing backend wallet via API:", data.message);
                walletConnectMessage.innerHTML = `<div class="text-danger">Error disconnecting backend: ${data.message}</div>`;
            }
        } catch (error) {
            console.error("Network error clearing backend wallet:", error);
            walletConnectMessage.innerHTML = `<div class="text-danger">Network error disconnecting backend: ${error.message}</div>`;
        }

        backendWalletConnectedAddress = null;
        privateKeyInput.value = '';
        walletAddressInput.value = '';
        nodeUrlInput.value = 'http://127.0.0.1:8545'; // Reset node URL input to Ganache default
        // Clear credentials from localStorage on disconnect
        localStorage.removeItem('backendPrivateKey');
        localStorage.removeItem('backendNodeUrl');

        // Disconnect MetaMask (clear local state and reset button/label)
        if (metaMaskConnectedAccount) {
            metaMaskConnectedAccount = null;
            web3MetaMask = null; // Clear Web3 instance for MetaMask
            console.log("MetaMask wallet disconnected (local state cleared).");
            alert("MetaMask wallet disconnected from BlockSense. You may need to manually disconnect this site in MetaMask if you wish to revoke site permissions.");
        }

        updateWalletRadioButtons(); // Re-evaluate states after disconnect (for modal radio buttons)
        updateConnectWalletButtonStatus(); // Update the header button
        walletConnectModal.hide(); // Close the modal
    };


    // --- Explain Contract Form Logic ---
    document.getElementById('formContract').onsubmit = async e => {
      e.preventDefault();
      const spinner = e.submitter.querySelector('.spinner-border');
      const loader = document.getElementById('explainLoader');
      const outputBox = document.getElementById('explanationBox');
      const output = document.getElementById('explanationCode');
      spinner.style.display = 'inline-block';
      loader.style.display = 'block';
      outputBox.style.display = 'none';
      try {
        const res = await fetch('/explain', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ contract: document.getElementById('contract').value })
        });
        const data = await res.json();
        output.innerText = data.explanation;
        outputBox.style.display = 'block';
        hljs.highlightAll();
      } catch {
        output.innerText = '‚ùå Error fetching explanation.';
        outputBox.style.display = 'block';
      }
      spinner.style.display = 'none';
      loader.style.display = 'none';
    };

    // --- Chat Form Logic ---
    document.getElementById('chatForm').onsubmit = async e => {
      e.preventDefault();
      const spinner = e.submitter.querySelector('.spinner-border');
      const loader = document.getElementById('chatLoader');
      const chatBox = document.getElementById('chatResponse');
      const input = document.getElementById('chat_input').value.trim(); // Trim input
      spinner.style.display = 'inline-block';
      loader.style.display = 'block';

      // --- Debugging logs ---
      console.log("--- Chat Form Submission DEBUG ---");
      console.log("Input:", input);
      console.log("radioMetaMask.checked:", radioMetaMask.checked);
      console.log("metaMaskConnectedAccount:", metaMaskConnectedAccount);
      console.log("radioBackendWallet.checked:", radioBackendWallet.checked);
      console.log("backendWalletConnectedAddress:", backendWalletConnectedAddress);
      // --- End Debugging logs ---

      try {
        let responseText = ''; // Initialize responseText

        // Patterns for client-side handled commands
        const balanceAddressMatch = input.match(/check balance of (0x[0-9a-fA-F]{40})/i);
        const generalBalanceMatch = input.match(/^(?:my\s+)?balance(?:\s*\?)?$/i);
        const transferMatch = input.match(/transfer\s+([\d.]+)\s*eth\s+to\s+(0x[0-9a-fA-F]{40})/i);

        // --- Client-side Wallet Command Handling ---
        if (transferMatch) {
            const amount = parseFloat(transferMatch[1]);
            const targetAddress = transferMatch[2];
            if (radioMetaMask.checked && metaMaskConnectedAccount && web3MetaMask) {
                try {
                    // Convert amount to string before passing to toWei for MetaMask transactions
                    const valueWei = web3MetaMask.utils.toWei(amount.toString(), 'ether');
                    const txHash = await web3MetaMask.eth.sendTransaction({
                        from: metaMaskConnectedAccount,
                        to: targetAddress,
                        value: valueWei,
                        gas: 21000 // Standard ETH transfer gas
                    });
                    responseText = `‚úÖ MetaMask transaction sent! Hash: <code>${txHash.transactionHash}</code>`;
                } catch (metaMaskError) {
                    responseText = `‚ùå MetaMask Transaction Error: ${metaMaskError.message}`;
                }
            } else {
                // If transfer request, but MetaMask not active, try backend
                // Or, if user explicitly selected backend wallet
                if (radioBackendWallet.checked && backendWalletConnectedAddress) {
                     // Still send to backend if backend wallet is active and client-side can't handle (e.g. transfer for backend)
                     // Re-using existing backend /chat route for transfer logic.
                    const res = await fetch('/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_input: input })
                    });
                    const data = await res.json();
                    responseText = data.response || data.error || 'Unknown error during backend transfer.';
                } else {
                     responseText = 'Please connect either a MetaMask or Backend wallet to perform transfers.';
                }
            }
        } else if (balanceAddressMatch) {
            const targetAddress = balanceAddressMatch[1];
            if (radioMetaMask.checked && web3MetaMask) {
                try {
                    const balanceWei = await web3MetaMask.eth.getBalance(targetAddress);
                    const balanceEth = web3MetaMask.utils.fromWei(balanceWei, 'ether');
                    responseText = `MetaMask: Balance of ${targetAddress}: ${parseFloat(balanceEth).toFixed(4)} ETH`;
                } catch (error) {
                    responseText = `MetaMask: Error getting balance for ${targetAddress}: ${error.message}`;
                }
            } else {
                // If balance check for specific address, but MetaMask not active, try backend
                if (radioBackendWallet.checked && backendWalletConnectedAddress) {
                    const res = await fetch('/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_input: input })
                    });
                    const data = await res.json();
                    responseText = `Backend: ${data.response || data.error || `Unknown error getting balance from backend.`}`;
                } else {
                    responseText = 'Please connect a wallet to check its balance.';
                }
            }
        } else if (generalBalanceMatch) {
            if (radioMetaMask.checked && metaMaskConnectedAccount && web3MetaMask) {
                try {
                    const balanceWei = await web3MetaMask.eth.getBalance(metaMaskConnectedAccount);
                    const balanceEth = web3MetaMask.utils.fromWei(balanceWei, 'ether');
                    responseText = `MetaMask: Balance of your connected account (${metaMaskConnectedAccount.substring(0, 6)}...): ${parseFloat(balanceEth).toFixed(4)} ETH`;
                } catch (error) {
                    responseText = `MetaMask: Error getting balance for connected account: ${error.message}`;
                }
            } else {
                // If general balance request, but MetaMask not active, try backend
                if (radioBackendWallet.checked && backendWalletConnectedAddress) {
                    const res = await fetch('/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_input: `check balance of ${backendWalletConnectedAddress}` }) // Send explicit query for backend
                    });
                    const data = await res.json();
                    responseText = `Backend: ${data.response || data.error || 'Unknown error getting balance from backend.'}`;
                } else {
                    responseText = 'Please connect a wallet to check its balance.';
                }
            }
        } else {
            // --- Default to backend for all other LLM commands ---
            const res = await fetch('/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ chat_input: input })
            });
            const data = await res.json();
            responseText = data.response || data.error || 'Unknown error.';
        }

        // Display the response
        chatBox.innerHTML += `<div><strong>You:</strong> ${input}</div><div><strong>AI:</strong> ${responseText}</div><hr>`;
        chatBox.style.display = 'block';
        chatBox.scrollTop = chatBox.scrollHeight;
        document.getElementById('chat_input').value = '';
      } catch (error) {
        chatBox.innerHTML += `<div><strong>Error:</strong> Could not fetch response or process transaction: ${error.message}</div>`;
        chatBox.style.display = 'block';
      }
      spinner.style.display = 'none';
      loader.style.display = 'none';
    };

    // --- Deploy Contract Logic ---
    async function deployContract() {
      const spinner = document.getElementById('deploySpinner');
      const loader = document.getElementById('deployLoader');
      const resultBox = document.getElementById('deployResult');
      spinner.style.display = 'inline-block';
      loader.style.display = 'block';
      resultBox.innerText = '';

      const abiString = document.getElementById('deployAbi').value.trim();
      const bytecode = document.getElementById('deployBytecode').value.trim();
      // Removed constructorArgs input field

      if (!abiString || !bytecode) {
        resultBox.innerHTML = '<div class="alert alert-warning mt-2">Please enter both ABI and Bytecode.</div>';
        spinner.style.display = 'none';
        loader.style.display = 'none';
        return;
      }

      let abi;
      try {
        abi = JSON.parse(abiString);
        if (!Array.isArray(abi)) {
            throw new Error("ABI must be a JSON array.");
        }
      } catch (e) {
        resultBox.innerHTML = `<div class="alert alert-danger mt-2">Invalid ABI: ${e.message}</div>`;
        spinner.style.display = 'none';
        loader.style.display = 'none';
        return;
      }

      try {
        let contractAddressOrError;
        if (radioMetaMask.checked && metaMaskConnectedAccount) {
            // MetaMask deployment
            const contract = new web3MetaMask.eth.Contract(abi);
            // No arguments passed to constructor
            const deployTx = contract.deploy({
                data: bytecode,
                arguments: [] // Pass empty array for arguments
            });
            const gasEstimate = await deployTx.estimateGas({ from: metaMaskConnectedAccount });

            const receipt = await deployTx.send({
                    from: metaMaskConnectedAccount,
                    gas: gasEstimate + 50000 // Add a buffer
                });
            contractAddressOrError = receipt.options.address; // Get deployed address from receipt
            resultBox.innerHTML = `<div class="alert alert-success mt-2">MetaMask Contract Deployed: ${contractAddressOrError}</div>`;
        } else {
            // Check if backend wallet is actually connected before attempting backend deploy
            if (!backendWalletConnectedAddress) {
                resultBox.innerHTML = '<div class="alert alert-warning mt-2">No backend wallet connected. Please connect one or switch to MetaMask.</div>';
                spinner.style.display = 'none';
                loader.style.display = 'none';
                return;
            }
            // Backend private key deployment (original flow)
            const res = await fetch('/deploy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ abi, bytecode }) // No constructor_args passed
            });
            const data = await res.json();
            if (data.contract_address) {
                contractAddressOrError = data.contract_address;
                resultBox.innerHTML = `<div class="alert alert-success mt-2">Backend Contract Deployed: ${contractAddressOrError}</div>`;
            } else {
                resultBox.innerHTML = '‚ùå ' + (data.error || 'Unknown error during backend deployment.');
            }
        }
      } catch (e) {
        resultBox.innerHTML = '‚ùå Error deploying contract: ' + e.message;
      }
      spinner.style.display = 'none';
      loader.style.display = 'none';
    }

    // --- Interact with Contract Logic ---
    async function interact() {
      const spinner = document.getElementById('interactSpinner');
      const loader = document.getElementById('interactLoader');
      const resultBox = document.getElementById('interactResult');
      spinner.style.display = 'inline-block';
      loader.style.display = 'block';
      resultBox.innerText = '';

      const abiString = document.getElementById('interactAbi').value.trim();
      const contract_address = document.getElementById('contractAddress').value.trim();
      const method = document.getElementById('methodName').value.trim();
      const argsString = document.getElementById('methodArgs').value.trim();

      if (!abiString || !contract_address || !method) {
        resultBox.innerHTML = '<div class="alert alert-warning mt-2">Please fill in ABI, Address, and Method.</div>';
        spinner.style.display = 'none';
        loader.style.display = 'none';
        return;
      }

      let abi;
      try {
        abi = JSON.parse(abiString);
        if (!Array.isArray(abi)) {
            throw new Error("ABI must be a JSON array.");
        }
      } catch (e) {
        resultBox.innerHTML = `<div class="alert alert-danger mt-2">Invalid ABI: ${e.message}</div>`;
        spinner.style.display = 'none';
        loader.style.display = 'none';
        return;
      }

      let args = [];
      if (argsString) {
          try {
              args = JSON.parse(`[${argsString}]`);
          } catch (e) {
              args = argsString.split(',').map(arg => arg.trim());
              args = args.map(arg => {
                  if (!isNaN(parseFloat(arg)) && isFinite(arg)) {
                      return parseFloat(arg);
                  }
                  return arg;
              });
          }
      }

      try {
        let result;
        // Check method's stateMutability to determine if it's a transaction (needs signing)
        const methodAbiEntry = abi.find(item => item.name === method && item.type === 'function');
        const isTransaction = methodAbiEntry && methodAbiEntry.stateMutability && !['view', 'pure'].includes(methodAbiEntry.stateMutability);

        if (radioMetaMask.checked && metaMaskConnectedAccount) {
            // MetaMask interaction
            const contract = new web3MetaMask.eth.Contract(abi, contract_address);
            if (isTransaction) {
                // Transaction method
                const tx = contract.methods[method](...args);
                const gasEstimate = await tx.estimateGas({ from: metaMaskConnectedAccount });
                const receipt = await tx.send({
                    from: metaMaskConnectedAccount,
                    gas: gasEstimate + 50000 // Add a buffer
                });
                result = `MetaMask Transaction Sent: ${receipt.transactionHash}. Status: ${receipt.status === true ? 'Success' : 'Failed'}`;
            } else {
                // Read-only method (call)
                result = await contract.methods[method](...args).call();
            }
        } else {
            // Check if backend wallet is actually connected before attempting backend interaction
            if (!backendWalletConnectedAddress) {
                resultBox.innerHTML = '<div class="alert alert-warning mt-2">No backend wallet connected. Please connect one or switch to MetaMask.</div>';
                spinner.style.display = 'none';
                loader.style.display = 'none';
                return;
            }
            // Backend private key interaction (original flow)
            const res = await fetch('/interact', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ abi, contract_address, method, args })
            });
            const data = await res.json();
            if (data.hasOwnProperty('result')) {
                result = data.result;
            } else {
                result = '‚ùå ' + (data.error || 'Unknown error during backend interaction.');
            }
        }

        // Display result
        if (typeof result === 'object' && result !== null) {
            resultBox.innerText = JSON.stringify(result, null, 2);
        } else {
            resultBox.innerText = result;
        }

      } catch (e) {
        resultBox.innerText = '‚ùå Error calling contract method: ' + e.message;
      }
      spinner.style.display = 'none';
      loader.style.display = 'none';
    }

    // --- BlockDAG Visualization Logic ---
    async function loadBlockDAG() {
      try {
        const res = await fetch('/blockdag');
        const blocks = await res.json();
        const nodes = [], edges = [];
        blocks.forEach(b => {
          nodes.push({ id: b.id, label: `${b.id}\n${b.tx_count} txs\n${b.producer}`, shape: 'box' });
          b.parents.forEach(p => edges.push({ from: p, to: b.id }));
        });
        new vis.Network(document.getElementById('blockdagGraph'), {
          nodes: new vis.DataSet(nodes),
          edges: new vis.DataSet(edges)
        }, {
          layout: { hierarchical: false },
          nodes: { color: '#58a6ff', font: { color: 'white' } },
          edges: { color: '#aaa', arrows: 'to' },
          physics: { enabled: true }
        });
      } catch (e) {
        console.error("Error loading BlockDAG:", e);
        document.getElementById('blockdagGraph').innerText = '‚ùå Error loading BlockDAG visualization.';
      }
    }

    // New function to initialize MetaMask state on load
    async function initMetaMaskState() {
        if (typeof window.ethereum !== 'undefined') {
            try {
                // eth_accounts returns an array of addresses connected to the site
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    web3MetaMask = new Web3(window.ethereum); // Initialize web3MetaMask
                    updateMetaMaskInternalState(accounts); // This will update metaMaskConnectedAccount and call updateWalletRadioButtons
                } else {
                    updateMetaMaskInternalState([]); // Call with empty array to clear state if no accounts
                }
            } catch (error) {
                console.error("Error checking initial MetaMask accounts:", error);
                updateMetaMaskInternalState([]); // Ensure state is cleared on error
            }
        } else {
            updateMetaMaskInternalState([]); // No window.ethereum, so clear MetaMask state
        }
    }

    // Function to attempt automatic backend wallet reconnection on load
    async function autoConnectBackendWallet() {
        const storedPrivateKey = localStorage.getItem('backendPrivateKey');
        const storedNodeUrl = localStorage.getItem('backendNodeUrl');

        if (storedPrivateKey && storedNodeUrl) {
            walletConnectMessage.innerHTML = '<div class="text-info">Attempting to reconnect backend wallet automatically...</div>';
            try {
                const res = await fetch('/set_wallet_config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ private_key: storedPrivateKey, node_url: storedNodeUrl })
                });
                const data = await res.json();

                if (data.status === 'success') {
                    backendWalletConnectedAddress = data.address;
                    console.log("Backend wallet reconnected automatically.");
                    walletConnectMessage.innerHTML = '<div class="text-success">Backend wallet reconnected automatically.</div>';
                } else {
                    console.error("Auto-reconnection failed:", data.message);
                    walletConnectMessage.innerHTML = `<div class="text-danger">Auto-reconnection failed: ${data.message}</div>`;
                    // Clear stored credentials if auto-reconnect fails
                    localStorage.removeItem('backendPrivateKey');
                    localStorage.removeItem('backendNodeUrl');
                    backendWalletConnectedAddress = null; // Ensure state is reset
                }
            } catch (error) {
                console.error("Network error during auto-reconnection:", error);
                walletConnectMessage.innerHTML = `<div class="text-danger">Network error during auto-reconnection: ${error.message}</div>`;
                // Clear stored credentials on network error
                localStorage.removeItem('backendPrivateKey');
                localStorage.removeItem('backendNodeUrl');
                backendWalletConnectedAddress = null; // Ensure state is reset
            }
        }
    }

    window.onload = async () => { // Make onload async
        loadBlockDAG();
        // Ensure private key and derived address inputs are empty on load
        privateKeyInput.value = '';
        walletAddressInput.value = '';
        nodeUrlInput.value = 'http://127.0.0.1:8545'; // Set default node URL

        // Load stored values if any, and set them in the input fields
        const storedPrivateKey = localStorage.getItem('backendPrivateKey');
        const storedNodeUrl = localStorage.getItem('backendNodeUrl');
        if (storedPrivateKey) {
            privateKeyInput.value = storedPrivateKey;
            // Attempt to derive address locally for display
            try {
                const account = web3.eth.accounts.privateKeyToAccount(storedPrivateKey);
                walletAddressInput.value = account.address;
            } catch (e) {
                console.error("Error deriving address from stored private key:", e);
                walletAddressInput.value = 'Invalid Stored Key';
            }
        }
        if (storedNodeUrl) {
            nodeUrlInput.value = storedNodeUrl;
        }

        // Call initial setup functions in order
        // Auto-connect backend first as it might be synchronous or quicker to get status
        await autoConnectBackendWallet();
        // Then initialize MetaMask state
        await initMetaMaskState();

        // Finally, update the header button to reflect the combined state
        updateConnectWalletButtonStatus();
    };

  </script>
</body>
</html>
