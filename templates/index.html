<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BlockSense</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
  <style>
    /* CSS Variables for theming */
    :root {
      --bg-dark: #0d1117;
      --card-dark: #161b22;
      --text-dark: #fff;
      --highlight-dark: #58a6ff;

      /* Input/Textarea/Pre/Code specific variables for dark mode */
      --input-bg: #0d1117;
      --input-color: white;
      --input-border: #444;
      --input-focus-border: var(--highlight-dark);
      --input-focus-shadow: rgba(88, 166, 255, 0.25);
      --placeholder-color: #bbb; /* Lighter grey for placeholders in dark mode */

      --loader-text-color: #aaa; /* Dark mode loader text */

      --output-pre-code-bg: #0d1117;
      --output-pre-code-color: white;
      --output-pre-code-border: #444;

      /* Alert colors for dark mode */
      --alert-success-bg: #198754; /* Bootstrap success green */
      --alert-success-text: #fff;
      --alert-danger-bg: #dc3545; /* Bootstrap danger red */
      --alert-danger-text: #fff;
      --alert-warning-bg: #ffc107; /* Bootstrap warning yellow */
      --alert-warning-text: #000; /* Black text on yellow for readability */
      --alert-info-bg: #0dcaf0; /* Bootstrap info cyan */
      --alert-info-text: #000; /* Black text on cyan for readability */
    }

    .light-mode {
      --bg-light: #f8f9fa;
      --card-light: #fff;
      --text-light: #000;
      --highlight-light: #007bff;

      /* Input/Textarea/Pre/Code specific variables for light mode */
      --input-bg: #fff;
      --input-color: #000;
      --input-border: #ccc;
      --input-focus-border: var(--highlight-light);
      --input-focus-shadow: rgba(0, 123, 255, 0.25);
      --placeholder-color: #777; /* Darker grey for placeholders in light mode */

      --loader-text-color: #555; /* Light mode loader text */

      --output-pre-code-bg: #f8f9fa;
      --output-pre-code-color: #000;
      --output-pre-code-border: #ccc;

      /* Alert colors for light mode */
      --alert-success-bg: #d1e7dd; /* Bootstrap success light green */
      --alert-success-text: #0f5132;
      --alert-danger-bg: #f8d7da; /* Bootstrap danger light red */
      --alert-danger-text: #842029;
      --alert-warning-bg: #fff3cd; /* Bootstrap warning light yellow */
      --alert-warning-text: #664d03;
      --alert-info-bg: #cff4fc; /* Bootstrap info light cyan */
      --alert-info-text: #055160;
    }

    /* Ensure HTML and Body take full viewport dimensions */
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      overflow-x: hidden; /* Prevent horizontal scroll */
    }

    /* New class for the main page background */
    .page-background {
      min-height: 100vh; /* Ensure it covers the full viewport height */
      width: 100vw; /* Ensure it covers the full viewport width */
      background-color: var(--bg-dark); /* Default for dark mode */
      color: var(--text-dark); /* Default text color */
      transition: background-color 0.3s, color 0.3s; /* Smooth transition */
      font-family: 'Segoe UI', sans-serif; /* Apply font here */
      position: absolute; /* Position absolutely to cover everything */
      top: 0;
      left: 0;
      z-index: -1; /* Place it behind other content */
    }

    .light-mode .page-background {
      background-color: var(--bg-light);
      color: var(--text-light);
    }

    /* Apply padding to the container instead of body for fixed header */
    .container {
      padding-top: 70px; /* Add padding for the fixed header */
      padding-bottom: 20px; /* Add some bottom padding */
      position: relative; /* Ensure container is above page-background */
      z-index: 0;
    }

    /* Headings, labels, and general paragraph text should also follow the text theme */
    h2, h3, h4, h5, h6, p, label {
      color: var(--text-dark);
      transition: color 0.3s; /* Smooth transition for text */
    }
    .light-mode h2, .light-mode h3, .light-mode h4, .light-mode h5, .light-mode h6, .light-mode p, .light-mode label {
      color: var(--text-light);
    }

    /* Specific fix for BlockSense H1 title */
    h1 {
      color: var(--text-dark) !important; /* Ensure it's always themed */
      transition: color 0.3s; /* Smooth transition */
    }
    .light-mode h1 {
      color: var(--text-light) !important; /* Ensure it's always themed */
    }


    /* Small text (like form-text) should also follow the theme */
    small.form-text.text-muted {
      color: var(--text-dark) !important; /* Use !important to override Bootstrap's .text-muted */
      transition: color 0.3s;
    }
    .light-mode small.form-text.text-muted {
      color: var(--text-light) !important;
    }

    /* Card styling */
    .card {
      border-radius: 12px;
      background-color: var(--card-dark);
      padding: 20px;
      margin-bottom: 20px;
      transition: background-color 0.3s;
    }

    .light-mode .card {
      background-color: var(--card-light);
    }

    /* Input/Textarea styling using new variables */
    textarea.form-control,
    input.form-control { /* Targeted specific input types and form-control class */
      width: 100%;
      border-radius: 8px;
      padding: 10px;
      border: 1px solid var(--input-border);
      background-color: var(--input-bg);
      color: var(--input-color);
      transition: background-color 0.3s, color 0.3s, border-color 0.3s;
    }

    /* Placeholder styling */
    textarea.form-control::placeholder,
    input.form-control::placeholder {
      color: var(--placeholder-color);
      opacity: 1; /* Firefox default opacity is lower */
      transition: color 0.3s;
    }

    /* Focus states for inputs */
    textarea.form-control:focus,
    input.form-control:focus {
      border-color: var(--input-focus-border);
      box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
      background-color: var(--input-bg); /* Keep background consistent on focus */
      color: var(--input-color); /* Keep text color consistent on focus */
    }

    /* Pre and Code styling using new variables */
    pre, code {
      background-color: var(--output-pre-code-bg);
      color: var(--output-pre-code-color);
      border: 1px solid var(--output-pre-code-border);
      border-radius: 8px; /* Ensure consistent border-radius */
      padding: 10px; /* Ensure consistent padding */
      transition: background-color 0.3s, color 0.3s, border-color 0.3s;
    }

    .output-box {
      border-radius:10px;
      padding:20px;
      margin-top:15px;
      overflow-x: auto;
    }

    pre code {
      white-space: pre-wrap;
      word-break: break-word;
    }

    .spinner-border {
      width: 1rem;
      height: 1rem;
      display: none;
      margin-left: 10px;
    }

    .loader-text {
      font-style: italic;
      font-size: 0.9rem;
      color: var(--loader-text-color); /* Use variable */
      margin-top: 0.5rem;
      display: none;
      transition: color 0.3s;
    }

    #blockdagGraph {
      height: 400px;
      border: 1px solid #333;
      border-radius: 8px;
      background-color: #1e1e1e; /* Specific for graph background */
      transition: background-color 0.3s, border-color 0.3s;
    }
    .light-mode #blockdagGraph {
      background-color: #f0f0f0; /* Light mode for graph background */
      border: 1px solid #ccc;
    }


    .header-buttons {
      position: fixed;
      top: 10px;
      right: 20px;
      z-index: 1000; /* Ensure header buttons are always on top */
      display: flex;
      gap: 10px;
      align-items: center; /* Align items vertically */
      background-color: var(--bg-dark); /* Ensure background for fixed header */
      padding: 10px 20px; /* Add some padding to the fixed header area */
      border-radius: 8px; /* Optional: smooth corners */
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Optional: subtle shadow */
      transition: background-color 0.3s, box-shadow 0.3s;
    }

    .light-mode .header-buttons {
        background-color: var(--bg-light); /* Light mode background */
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    /* Modal specific styles for dark/light mode */
    .modal-content {
      background-color: var(--card-dark);
      border-radius: 12px;
      color: var(--text-dark); /* Ensure modal content text is themed */
      transition: background-color 0.3s, color 0.3s;
    }

    .light-mode .modal-content {
      background-color: var(--card-light);
      color: var(--text-light); /* Ensure modal content text is themed */
    }

    .modal-header, .modal-footer {
      border-color: #444; /* Dark mode border */
      transition: border-color 0.3s;
    }

    .light-mode .modal-header, .light-mode .modal-footer {
      border-color: #ccc; /* Light mode border */
    }

    .modal-header .btn-close {
      filter: invert(1); /* Ensure close button is visible in dark mode */
    }

    .light-mode .modal-header .btn-close {
      filter: invert(0); /* Ensure close button is visible in light mode */
    }

    /* Override Bootstrap's alert and specific text utility classes for theme adherence */
    .alert {
      border: 1px solid transparent; /* Remove default Bootstrap border */
      transition: background-color 0.3s, color 0.3s;
      color: var(--text-dark) !important; /* Default text color for alerts in dark mode */
    }
    .light-mode .alert {
      color: var(--text-light) !important; /* Default text color for alerts in light mode */
    }

    .alert.alert-success {
      background-color: var(--alert-success-bg);
    }
    .alert.alert-danger {
      background-color: var(--alert-danger-bg);
    }
    .alert.alert-warning {
      background-color: var(--alert-warning-bg);
    }
    .alert.alert-info {
      background-color: var(--alert-info-bg);
    }

    /* Ensure specific elements in the chat response box also follow the theme */
    #chatResponse div, #chatResponse strong {
      color: var(--text-dark); /* Default for dark mode */
      transition: color 0.3s;
    }
    .light-mode #chatResponse div, .light-mode #chatResponse strong {
      color: var(--text-light); /* For light mode */
    }

    /* Added for wallet selection */
    .wallet-selection-group label {
        margin-right: 15px;
        color: var(--text-dark); /* Ensure labels are themed */
        transition: color 0.3s;
    }
    .light-mode .wallet-selection-group label {
        color: var(--text-light); /* Ensure labels are themed */
    }


    /* Custom styles for MetaMask button based on image */
    #connectMetaMaskBtn {
        width: 100%;
        padding: 10px 20px;
        font-size: 1.1rem;
        font-weight: bold;
        background-color: #007bff; /* Primary blue */
        border-color: #007bff;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2);
        transition: background-color 0.2s, box-shadow 0.2s;
    }

    #connectMetaMaskBtn:hover {
        background-color: #0056b3; /* Darker blue on hover */
        border-color: #0056b3;
        box-shadow: 0 6px 12px rgba(0, 123, 255, 0.3);
    }

    /* Ensure the button is always clickable */
    #connectWalletBtn {
        pointer-events: auto !important;
    }


    .or-separator {
        display: flex;
        align-items: center;
        text-align: center;
        margin: 20px 0;
        color: var(--text-dark); /* Default for dark mode */
        transition: color 0.3s;
    }

    .light-mode .or-separator {
      color: var(--text-light);
    }

    .or-separator::before,
    .or-separator::after {
        content: '';
        flex: 1;
        border-bottom: 1px solid #444; /* Line color for dark mode */
        transition: border-color 0.3s;
    }

    .light-mode .or-separator::before,
    .light-mode .or-separator::after {
      border-bottom: 1px solid #ccc; /* Line color for light mode */
    }

    .or-separator:not(:empty)::before {
        margin-right: .25em;
    }

    .or-separator:not(:empty)::after {
        margin-left: .25em;
    }

    /* New style for theme toggle in light mode */
    .light-mode #themeToggle {
        background-color: black !important;
        color: white !important;
        border-color: black !important;
    }
  </style>
</head>

<body class="dark-mode">
  <!-- This div will act as the main page background -->
  <div class="page-background"></div>

  <div class="header-buttons">
    <button id="connectWalletBtn" class="btn btn-sm btn-outline-light">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-wallet" viewBox="0 0 16 16">
        <path d="M0 3a2 2 0 0 1 2-2h13.5a.5.5 0 0 1 0 1H2a1 1 0 0 0-1 1v8.5a1 1 0 0 0 1 1h12.5a.5.5 0 = 0 1 0 1H2a2 2 0 0 1-2-2z"/>
        <path d="M11.5 5a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5z"/>
      </svg>
      Connect Wallet
    </button>
    <button id="themeToggle" class="btn btn-sm btn-outline-light">‚òÄÔ∏è Light Mode</button>
  </div>
  <div class="container py-5">
    <h1 class="text-center mb-4 animate__animated animate__fadeInDown">üöÄ BlockSense</h1>

    <div class="card animate__animated animate__fadeInUp">
      <h4>üß† Explain Solidity Contract</h4>
      <form id="formContract">
        <div class="mb-3">
          <textarea id="contract" class="form-control" rows="10" placeholder="Paste your Solidity code..." required></textarea>
        </div>
        <div class="text-end mt-2">
          <button type="submit" class="btn btn-success">
            Explain üîç <span class="spinner-border spinner-border-sm"></span>
          </button>
          <div id="explainLoader" class="loader-text">üîÑ Processing contract...</div>
        </div>
      </form>
      <div class="output-box" id="explanationBox" style="display:none">
        <pre><code id="explanationCode" class="hljs"></code></pre>
      </div>
    </div>

    <div class="card animate__animated animate__fadeInUp">
      <h4>ü§ñ EVM Chatbot</h4>
      <form id="chatForm">
        <div class="mb-3">
          <textarea id="chat_input" class="form-control" rows="3" placeholder="Say ‚Äòtransfer 0.1 ETH to 0x...‚Äô" required></textarea>
        </div>
        <div class="text-end mt-2">
          <button type="submit" class="btn btn-info">
            Send <span class="spinner-border spinner-border-sm"></span>
          </button>
          <div id="chatLoader" class="loader-text">üí¨ AI is thinking...</div>
        </div>
      </form>
      <div class="output-box" id="chatResponse" style="display:none"></div>
    </div>

    <div class="card animate__animated animate__fadeInUp">
      <h4>üì¶ Deploy Contract</h4>
      <div class="mb-3">
        <textarea id="deployAbi" class="form-control" rows="4" placeholder="Enter ABI as JSON..."></textarea>
      </div>
      <div class="mb-3">
        <textarea id="deployBytecode" class="form-control" rows="4" placeholder="Enter Bytecode..."></textarea>
      </div>
      <div class="text-end mt-2">
        <button class="btn btn-warning" onclick="deployContract()">
          Deploy <span class="spinner-border spinner-border-sm" id="deploySpinner"></span>
        </button>
        <div id="deployLoader" class="loader-text">üöÄ Deploying contract...</div>
      </div>
      <div id="deployResult" class="output-box mt-2"></div>
    </div>

    <div class="card animate__animated animate__fadeInUp">
      <h4>üîß Interact with Contract</h4>
      <div class="mb-3">
        <textarea id="interactAbi" class="form-control" rows="4" placeholder="Enter ABI as JSON..."></textarea>
      </div>
      <div class="mb-3">
        <input id="contractAddress" class="form-control" placeholder="Contract Address" />
      </div>
      <div class="mb-3">
        <input id="methodName" class="form-control" placeholder="Method Name" />
      </div>
      <div class="mb-3">
        <input id="methodArgs" class="form-control" placeholder="Arguments (comma-separated)" />
        <small class="form-text text-muted">For strings, use quotes: "hello", "world". For numbers, just the number: 123. For booleans: true, false.</small>
      </div>
      <div class="text-end mt-2">
        <button class="btn btn-primary" onclick="interact()">
          Call <span class="spinner-border spinner-border-sm" id="interactSpinner"></span>
        </button>
        <div id="interactLoader" class="loader-text">‚öôÔ∏è Interacting with contract...</div>
      </div>
      <div id="interactResult" class="output-box mt-2"></div>
    </div>

    <!-- NEW: Contract Verification Section -->
    <div class="card animate__animated animate__fadeInUp">
      <h4>‚úÖ Verify Smart Contract Source Code</h4>
      <div class="mb-3">
        <input id="verifyContractAddressInput" class="form-control" placeholder="Contract Address (0x...)" />
      </div>
      <div class="mb-3">
        <textarea id="verifySourceCodeInput" class="form-control" rows="10" placeholder="Paste your Solidity source code here..."></textarea>
      </div>
      <div class="mb-3">
        <input id="verifyContractNameInput" class="form-control" placeholder="Contract Name (e.g., MyContract)" />
      </div>
      <div class="mb-3">
        <input id="verifyCompilerVersionInput" class="form-control" placeholder="Compiler Version (e.g., v0.8.17+commit.8df45f5f)" />
        <small class="form-text text-muted">Must match Etherscan's format. Check their docs for exact versions.</small>
      </div>
      <div class="form-check mb-3">
        <input class="form-check-input" type="checkbox" id="verifyOptimizationUsed">
        <label class="form-check-label" for="verifyOptimizationUsed">
          Optimization Used
        </label>
      </div>
      <div class="mb-3" id="verifyRunsGroup" style="display:none;">
        <label for="verifyRunsInput" class="form-label">Runs (if optimization used)</label>
        <input type="number" class="form-control" id="verifyRunsInput" value="200" min="1">
      </div>
      <div class="text-end mt-2">
        <button class="btn btn-success" id="verifyContractBtn">
          Verify <span class="spinner-border spinner-border-sm" id="verifySpinner"></span>
        </button>
        <div id="verifyLoader" class="loader-text">üì§ Submitting for verification...</div>
      </div>
      <div id="verifyOutput" class="output-box mt-2" style="display:none;"></div>
    </div>
    <!-- END NEW: Contract Verification Section -->

    <div class="card animate__animated animate__fadeInUp">
      <h4>üåê BlockDAG Visualization</h4>
      <div id="blockdagGraph"></div>
    </div>
  </div>

  <div class="modal fade" id="walletConnectModal" tabindex="-1" aria-labelledby="walletConnectModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="walletConnectModalLabel">Connect Your Wallet</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <!-- Removed the warning section as requested -->

          <button type="button" class="btn btn-info" id="connectMetaMaskBtn">Connect with MetaMask</button>

          <div class="or-separator">OR</div>

          <div class="mb-3">
            <label for="privateKeyInput" class="form-label">Private Key (for test accounts):</label>
            <input type="password" class="form-control" id="privateKeyInput" placeholder="Enter your private key (e.g., 0x...)">
          </div>
          <div class="mb-3">
            <label for="nodeUrlInput" class="form-label">EVM Node URL (e.g., http://127.0.0.1:8545 or https://sepolia.infura.io/v3/...):</label>
            <input type="text" class="form-control" id="nodeUrlInput" placeholder="Enter your EVM node URL">
          </div>
          <div class="mb-3">
            <label for="walletAddressInput" class="form-label">Active Wallet Address:</label>
            <input type="text" class="form-control" id="walletAddressInput" readonly placeholder="Not Connected">
          </div>
          <div id="walletConnectMessage" class="mt-3"></div>
          <button type="button" class="btn btn-primary" id="confirmConnectBtn">
            Connect Backend Wallet <span class="spinner-border spinner-border-sm" id="connectWalletSpinner"></span>
          </button>

          <hr>

          <h5>Active Transaction Wallet:</h5>
          <div class="wallet-selection-group">
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="radio" name="activeWallet" id="radioBackendWallet" value="backend">
              <label class="form-check-label" for="radioBackendWallet">Backend (Private Key)</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="radio" name="activeWallet" id="radioMetaMask" value="metamask" disabled>
              <label class="form-check-label" for="radioMetaMask">MetaMask (Not Connected)</label>
            </div>
          </div>

        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          <button type="button" class="btn btn-danger" id="disconnectWalletBtn">Disconnect All Wallets</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
    // Initialize Web3 for client-side address derivation (for privateKeyInput)
    const web3 = new Web3();

    // --- Theme Toggle Logic (Original) ---
    function applyTheme(mode) {
      document.body.classList.toggle('dark-mode', mode === 'dark');
      document.body.classList.toggle('light-mode', mode === 'light');

      // Update the page-background div's class
      const pageBackground = document.querySelector('.page-background');
      if (pageBackground) {
          pageBackground.classList.toggle('dark-mode', mode === 'dark');
          pageBackground.classList.toggle('light-mode', mode === 'light');
      }

      document.getElementById('themeToggle').innerText = mode === 'light' ? 'üåô Dark Mode' : '‚òÄÔ∏è Light Mode';
      localStorage.setItem('theme', mode);
      console.log(`Applying theme: ${mode}. Body classes: ${document.body.classList}`); // Debugging log
      const computedHtmlBg = window.getComputedStyle(document.documentElement).backgroundColor;
      const computedBodyBg = window.getComputedStyle(document.body).backgroundColor;
      const computedBodyColor = window.getComputedStyle(document.body).color;
      const computedPageBgColor = pageBackground ? window.getComputedStyle(pageBackground).backgroundColor : 'N/A';
      console.log(`Computed HTML background-color: ${computedHtmlBg}`);
      console.log(`Computed Body background-color: ${computedBodyBg}, color: ${computedBodyColor}`);
      console.log(`Computed Page Background background-color: ${computedPageBgColor}`);

      const h1Element = document.querySelector('h1');
      if (h1Element) {
          const computedH1Color = window.getComputedStyle(h1Element).color;
          console.log(`Computed H1 color: ${computedH1Color}`);
      }


      const connectWalletBtn = document.getElementById('connectWalletBtn');
      connectWalletBtn.classList.remove('btn-outline-light', 'btn-outline-dark');
      if (mode === 'light') {
        connectWalletBtn.classList.add('btn-outline-dark');
      } else {
        connectWalletBtn.classList.add('btn-outline-light');
      }
    }

    document.getElementById('themeToggle').onclick = () => {
      const newMode = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
      applyTheme(newMode);
    };
    applyTheme(localStorage.getItem('theme') || 'dark'); // Apply theme on initial load


    // --- Wallet Selection Elements ---
    const radioBackendWallet = document.getElementById('radioBackendWallet');
    const radioMetaMask = document.getElementById('radioMetaMask');
    const connectWalletButtonHeader = document.getElementById('connectWalletBtn'); // Get the button in the header

    // --- Global Wallet State ---
    let backendWalletConnectedAddress = null; // Stores the address connected via private key (backend)
    let web3MetaMask; // Web3 instance connected to MetaMask provider
    let metaMaskConnectedAccount = null; // Stores MetaMask's currently selected account

    // --- Connect Wallet Modal Logic (Backend Private Key) ---
    const walletConnectModal = new bootstrap.Modal(document.getElementById('walletConnectModal'));
    const privateKeyInput = document.getElementById('privateKeyInput');
    const nodeUrlInput = document.getElementById('nodeUrlInput'); // New input for node URL
    const walletAddressInput = document.getElementById('walletAddressInput');
    const confirmConnectBtn = document.getElementById('confirmConnectBtn');
    const connectWalletSpinner = document.getElementById('connectWalletSpinner');
    const walletConnectMessage = document.getElementById('walletConnectMessage');

    connectWalletButtonHeader.onclick = () => { // Event listener for the header button
      console.log("Connect Wallet button clicked! Disabled state:", connectWalletButtonHeader.disabled); // Added for debugging
      walletConnectMessage.innerHTML = ''; // Clear previous messages
      updateWalletRadioButtons(); // Ensure radio buttons and status are up-to-date
      walletConnectModal.show();
    };

    privateKeyInput.oninput = () => {
      const privateKey = privateKeyInput.value.trim();
      if (privateKey.startsWith('0x') && privateKey.length === 66) { // Basic check for 0x + 64 hex chars
        try {
          const account = web3.eth.accounts.privateKeyToAccount(privateKey);
          walletAddressInput.value = account.address;
          walletConnectMessage.innerHTML = '';
        } catch (error) {
          walletAddressInput.value = 'Invalid Key';
          walletConnectMessage.innerHTML = '<div class="alert alert-danger mt-2">Invalid private key format.</div>';
        }
      } else {
        walletAddressInput.value = '';
        walletConnectMessage.innerHTML = '';
        if (privateKey.length > 0) {
            walletConnectMessage.innerHTML = '<div class="alert alert-warning mt-2">Private key should start with "0x" and be 66 characters long.</div>';
        }
      }
    };

    confirmConnectBtn.onclick = async () => {
      const privateKey = privateKeyInput.value.trim();
      const nodeUrl = nodeUrlInput.value.trim(); // Get the node URL

      if (!privateKey) {
        walletConnectMessage.innerHTML = '<div class="alert alert-danger mt-2">Please enter your private key.</div>';
        return;
      }
      if (!nodeUrl) {
        walletConnectMessage.innerHTML = '<div class="alert alert-danger mt-2">Please enter your EVM Node URL.</div>';
        return;
      }

      connectWalletSpinner.style.display = 'inline-block';
      confirmConnectBtn.disabled = true;
      walletConnectMessage.innerHTML = '<div class="alert alert-info mt-2">Connecting backend wallet...</div>';

      try {
        const res = await fetch('/set_wallet_config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ private_key: privateKey, node_url: nodeUrl }) // Send node URL
        });
        const data = await res.json();

        if (data.status === 'success') {
          backendWalletConnectedAddress = data.address; // Store for later use
          walletConnectMessage.innerHTML = `<div class="alert alert-success mt-2">Backend Wallet Connected: ${data.address}</div>`;
          // Save credentials to localStorage on successful connection
          localStorage.setItem('backendPrivateKey', privateKey);
          localStorage.setItem('backendNodeUrl', nodeUrl);
          updateWalletRadioButtons(); // Update UI state after connection
          setTimeout(() => walletConnectModal.hide(), 1500);
        } else {
          backendWalletConnectedAddress = null; // Clear if connection fails
          walletConnectMessage.innerHTML = `<div class="alert alert-danger mt-2">Error: ${data.message}</div>`;
          // Clear localStorage if connection fails
          localStorage.removeItem('backendPrivateKey');
          localStorage.removeItem('backendNodeUrl');
          updateWalletRadioButtons(); // Update UI state after failure
        }
      } catch (error) {
        backendWalletConnectedAddress = null; // Clear on network error
        walletConnectMessage.innerHTML = `<div class="alert alert-danger mt-2">Network error: ${error.message}</div>`;
        // Clear localStorage on network error
        localStorage.removeItem('backendPrivateKey');
        localStorage.removeItem('backendNodeUrl');
        updateWalletRadioButtons(); // Update UI state after network error
      } finally {
        connectWalletSpinner.style.display = 'none';
        confirmConnectBtn.disabled = false;
      }
    };

    // --- MetaMask Wallet Logic (Client-Side for Transactions) ---
    const connectMetaMaskBtn = document.getElementById('connectMetaMaskBtn');

    // Function to update MetaMask's internal state and radio button
    const updateMetaMaskInternalState = async (accounts) => {
      if (accounts && accounts.length > 0) {
        metaMaskConnectedAccount = accounts[0];
        // Ensure web3MetaMask is initialized if accounts are found
        if (typeof window.ethereum !== 'undefined' && !web3MetaMask) {
          web3MetaMask = new Web3(window.ethereum);
        }

        if (typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask && web3MetaMask) {
          try {
            const balanceWei = await web3MetaMask.eth.getBalance(metaMaskConnectedAccount);
            const balanceEth = web3MetaMask.utils.fromWei(balanceWei, 'ether');
            console.log(`MetaMask Balance: ${parseFloat(balanceEth).toFixed(4)} ETH`);
            const currentChainId = await web3MetaMask.eth.getChainId();
            console.log(`MetaMask Chain ID: ${currentChainId}`);
          } catch (error) {
            console.error("Error fetching MetaMask details:", error);
          }
        }
      } else {
        // No accounts connected or accounts array is empty
        metaMaskConnectedAccount = null;
        web3MetaMask = null; // Clear web3MetaMask instance
      }
      updateWalletRadioButtons(); // Always update UI state after MetaMask internal state changes
    };

    // Function to initiate MetaMask connection (on button click)
    const connectMetaMask = async () => {
      if (typeof window.ethereum !== 'undefined') {
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          web3MetaMask = new Web3(window.ethereum); // Initialize web3MetaMask here as well
          updateMetaMaskInternalState(accounts);
        } catch (error) {
          console.error("User rejected connection or other MetaMask error:", error);
          alert('MetaMask connection failed or rejected: ' + error.message);
        }
      } else {
        // Mobile deep link logic
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const isMobile = /android|iphone|ipad|ipod|blackberry|windows phone/i.test(userAgent);

        if (isMobile) {
          // Use window.location.href directly as it provides the full, unencoded URL
          const metamaskDeepLink = `https://metamask.app.link/dapp/${window.location.href}`;

          console.log("Attempting MetaMask deep link:", metamaskDeepLink); // Log for debugging
          alert("MetaMask is not detected in this browser. Attempting to open in MetaMask mobile app...");
          window.open(metamaskDeepLink, '_blank'); // Open in new tab/app
        } else {
          // Desktop browser without MetaMask installed
          alert('MetaMask is not installed. Please install it to use this feature.');
        }
      }
    };

    connectMetaMaskBtn.addEventListener('click', connectMetaMask);

    // Listen for MetaMask accounts and chain changes proactively if ethereum object is present
    if (typeof window.ethereum !== 'undefined') {
      window.ethereum.on('accountsChanged', (accounts) => {
        console.log("MetaMask accounts changed:", accounts);
        updateMetaMaskInternalState(accounts);
      });

      window.ethereum.on('chainChanged', (chainId) => {
        console.log("MetaMask chain changed:", chainId);
        // Re-fetch accounts to ensure status update after chain change
        window.ethereum.request({ method: 'eth_accounts' })
          .then(updateMetaMaskInternalState)
          .catch(error => console.error("Error after chain changed:", error));
      });
    }

    // Function to update the state of the wallet radio buttons (inside modal)
    function updateWalletRadioButtons() {
        // Update MetaMask radio button and button state
        if (metaMaskConnectedAccount) {
            radioMetaMask.disabled = false;
            radioMetaMask.parentElement.querySelector('label').textContent = `MetaMask (${metaMaskConnectedAccount.substring(0, 6)}...)`;
            connectMetaMaskBtn.textContent = 'MetaMask Connected';
            connectMetaMaskBtn.classList.remove('btn-info');
            connectMetaMaskBtn.classList.add('btn-success');
            connectMetaMaskBtn.disabled = true; // Disable if already connected
        } else {
            radioMetaMask.disabled = true;
            radioMetaMask.parentElement.querySelector('label').textContent = 'MetaMask (Not Connected)';
            connectMetaMaskBtn.textContent = 'Connect with MetaMask';
            connectMetaMaskBtn.classList.remove('btn-success');
            connectMetaMaskBtn.classList.add('btn-info');
            connectMetaMaskBtn.disabled = false; // Enable if not connected
        }

        // Update Backend radio button state
        if (backendWalletConnectedAddress) {
            radioBackendWallet.disabled = false;
            radioBackendWallet.parentElement.querySelector('label').textContent = `Backend (${backendWalletConnectedAddress.substring(0, 6)}...)`;
        } else {
            radioBackendWallet.disabled = true;
            radioBackendWallet.parentElement.querySelector('label').textContent = 'Backend (Private Key)';
        }

        // Determine which wallet is actively selected for the radio buttons
        if (metaMaskConnectedAccount) {
            radioMetaMask.checked = true;
            radioBackendWallet.checked = false;
        } else if (backendWalletConnectedAddress) {
            radioBackendWallet.checked = true;
            radioMetaMask.checked = false;
        } else {
            radioBackendWallet.checked = false;
            radioMetaMask.checked = false;
        }
    }

    // Simplified function to update the header's Connect Wallet button appearance
    function updateConnectWalletButtonStatus() {
        // Always display "Connect Wallet" text
        connectWalletButtonHeader.textContent = "Connect Wallet";
        connectWalletButtonHeader.classList.remove('btn-success', 'connected'); // Remove connected styles
        // Re-apply correct outline color based on current theme
        const currentTheme = localStorage.getItem('theme') || 'dark';
        if (currentTheme === 'light') {
            connectWalletButtonHeader.classList.add('btn-outline-dark');
        } else {
            connectWalletButtonHeader.classList.add('btn-outline-light');
        }
        connectWalletButtonHeader.disabled = false; // Ensure button is always enabled
    }


    // --- Disconnect Wallet Button Logic ---
    const disconnectWalletBtn = document.getElementById('disconnectWalletBtn');

    disconnectWalletBtn.onclick = async () => {
        // Disconnect Backend Wallet (clear state locally and via backend API)
        try {
            const res = await fetch('/clear_wallet_config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            const data = await res.json();
            if (data.status === 'success') {
                console.log("Backend wallet disconnected via API.");
                walletConnectMessage.innerHTML = '<div class="alert alert-success mt-2">Backend wallet disconnected.</div>';
            } else {
                console.error("Error clearing backend wallet via API:", data.message);
                walletConnectMessage.innerHTML = `<div class="alert alert-danger mt-2">Error disconnecting backend: ${data.message}</div>`;
            }
        } catch (error) {
            console.error("Network error clearing backend wallet:", error);
            walletConnectMessage.innerHTML = `<div class="alert alert-danger mt-2">Network error disconnecting backend: ${error.message}</div>`;
        }

        backendWalletConnectedAddress = null;
        privateKeyInput.value = '';
        walletAddressInput.value = '';
        nodeUrlInput.value = 'http://127.0.0.1:8545'; // Reset node URL input to Ganache default
        // Clear credentials from localStorage on disconnect
        localStorage.removeItem('backendPrivateKey');
        localStorage.removeItem('backendNodeUrl');

        // Disconnect MetaMask (clear local state and reset button/label)
        if (metaMaskConnectedAccount) {
            metaMaskConnectedAccount = null;
            web3MetaMask = null; // Clear Web3 instance for MetaMask
            console.log("MetaMask wallet disconnected (local state cleared).");
            alert("MetaMask wallet disconnected from BlockSense. You may need to manually disconnect this site in MetaMask if you wish to revoke site permissions.");
        }

        updateWalletRadioButtons(); // Re-evaluate states after disconnect (for modal radio buttons)
        updateConnectWalletButtonStatus(); // Update the header button
        walletConnectModal.hide(); // Close the modal
    };


    // --- Explain Contract Form Logic ---
    document.getElementById('formContract').onsubmit = async e => {
      e.preventDefault();
      const spinner = e.submitter.querySelector('.spinner-border');
      const loader = document.getElementById('explainLoader');
      const outputBox = document.getElementById('explanationBox');
      const output = document.getElementById('explanationCode');
      spinner.style.display = 'inline-block';
      loader.style.display = 'block';
      outputBox.style.display = 'none';
      try {
        const res = await fetch('/explain', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ contract: document.getElementById('contract').value })
        });
        const data = await res.json();
        output.innerText = data.explanation;
        outputBox.style.display = 'block';
        hljs.highlightAll();
      } catch {
        output.innerText = '‚ùå Error fetching explanation.';
        outputBox.style.display = 'block';
      }
      spinner.style.display = 'none';
      loader.style.display = 'none';
    };

    // --- Chat Form Logic ---
    document.getElementById('chatForm').onsubmit = async e => {
      e.preventDefault();
      const spinner = e.submitter.querySelector('.spinner-border');
      const loader = document.getElementById('chatLoader');
      const chatBox = document.getElementById('chatResponse');
      const input = document.getElementById('chat_input').value.trim(); // Trim input
      spinner.style.display = 'inline-block';
      loader.style.display = 'block';

      // --- Debugging logs ---
      console.log("--- Chat Form Submission DEBUG ---");
      console.log("Input:", input);
      console.log("radioMetaMask.checked:", radioMetaMask.checked);
      console.log("metaMaskConnectedAccount:", metaMaskConnectedAccount);
      console.log("radioBackendWallet.checked:", radioBackendWallet.checked);
      console.log("backendWalletConnectedAddress:", backendWalletConnectedAddress);
      // --- End Debugging logs ---

      try {
        let responseText = ''; // Initialize responseText

        // Patterns for client-side handled commands
        const balanceAddressMatch = input.match(/check balance of (0x[0-9a-fA-F]{40})/i);
        const generalBalanceMatch = input.match(/^(?:my\s+)?balance(?:\s*\?)?$/i);
        const transferMatch = input.match(/transfer\s+([\d.]+)\s*eth\s+to\s+(0x[0-9a-fA-F]{40})/i);

        // --- Client-side Wallet Command Handling ---
        if (transferMatch) {
            const amount = parseFloat(transferMatch[1]);
            const targetAddress = transferMatch[2];
            if (radioMetaMask.checked && metaMaskConnectedAccount && web3MetaMask) {
                try {
                    // Convert amount to string before passing to toWei for MetaMask transactions
                    const valueWei = web3MetaMask.utils.toWei(amount.toString(), 'ether');
                    const txHash = await web3MetaMask.eth.sendTransaction({
                        from: metaMaskConnectedAccount,
                        to: targetAddress,
                        value: valueWei,
                        gas: 21000 // Standard ETH transfer gas
                    });
                    responseText = `‚úÖ MetaMask transaction sent! Hash: <code>${txHash.transactionHash}</code>`;
                } catch (metaMaskError) {
                    responseText = `‚ùå MetaMask Transaction Error: ${metaMaskError.message}`;
                }
            } else {
                // If transfer request, but MetaMask not active, try backend
                // Or, if user explicitly selected backend wallet
                if (radioBackendWallet.checked && backendWalletConnectedAddress) {
                     // Still send to backend if backend wallet is active and client-side can't handle (e.g. transfer for backend)
                     // Re-using existing backend /chat route for transfer logic.
                    const res = await fetch('/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_input: input })
                    });
                    const data = await res.json();
                    responseText = data.response || data.error || 'Unknown error during backend transfer.';
                } else {
                     responseText = 'Please connect either a MetaMask or Backend wallet to perform transfers.';
                }
            }
        } else if (balanceAddressMatch) {
            const targetAddress = balanceAddressMatch[1];
            if (radioMetaMask.checked && web3MetaMask) {
                try {
                    const balanceWei = await web3MetaMask.eth.getBalance(targetAddress);
                    const balanceEth = web3MetaMask.utils.fromWei(balanceWei, 'ether');
                    responseText = `MetaMask: Balance of ${targetAddress}: ${parseFloat(balanceEth).toFixed(4)} ETH`;
                } catch (error) {
                    responseText = `MetaMask: Error getting balance for ${targetAddress}: ${error.message}`;
                }
            } else {
                // If balance check for specific address, but MetaMask not active, try backend
                if (radioBackendWallet.checked && backendWalletConnectedAddress) {
                    const res = await fetch('/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_input: input })
                    });
                    const data = await res.json();
                    responseText = `Backend: ${data.response || data.error || `Unknown error getting balance from backend.`}`;
                } else {
                    responseText = 'Please connect a wallet to check its balance.';
                }
            }
        } else if (generalBalanceMatch) {
            if (radioMetaMask.checked && metaMaskConnectedAccount && web3MetaMask) {
                try {
                    const balanceWei = await web3MetaMask.eth.getBalance(metaMaskConnectedAccount);
                    const balanceEth = web3MetaMask.utils.fromWei(balanceWei, 'ether');
                    responseText = `MetaMask: Balance of your connected account (${metaMaskConnectedAccount.substring(0, 6)}...): ${parseFloat(balanceEth).toFixed(4)} ETH`;
                } catch (error) {
                    responseText = `MetaMask: Error getting balance for connected account: ${error.message}`;
                }
            } else {
                // If general balance request, but MetaMask not active, try backend
                if (radioBackendWallet.checked && backendWalletConnectedAddress) {
                    const res = await fetch('/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_input: `check balance of ${backendWalletConnectedAddress}` }) // Send explicit query for backend
                    });
                    const data = await res.json();
                    responseText = `Backend: ${data.response || data.error || 'Unknown error getting balance from backend.'}`;
                } else {
                    responseText = 'Please connect a wallet to check its balance.';
                }
            }
        } else {
            // --- Default to backend for all other LLM commands ---
            const res = await fetch('/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ chat_input: input })
            });
            const data = await res.json();
            responseText = data.response || data.error || 'Unknown error.';
        }

        // Display the response
        chatBox.innerHTML += `<div><strong>You:</strong> ${input}</div><div><strong>AI:</strong> ${responseText}</div><hr>`;
        chatBox.style.display = 'block';
        chatBox.scrollTop = chatBox.scrollHeight;
        document.getElementById('chat_input').value = '';
      } catch (error) {
        chatBox.innerHTML += `<div><strong>Error:</strong> Could not fetch response or process transaction: ${error.message}</div>`;
        chatBox.style.display = 'block';
      }
      spinner.style.display = 'none';
      loader.style.display = 'none';
    };

    // --- Deploy Contract Logic ---
    async function deployContract() {
      const spinner = document.getElementById('deploySpinner');
      const loader = document.getElementById('deployLoader');
      const resultBox = document.getElementById('deployResult');
      spinner.style.display = 'inline-block';
      loader.style.display = 'block';
      resultBox.innerText = '';

      const abiString = document.getElementById('deployAbi').value.trim();
      const bytecode = document.getElementById('deployBytecode').value.trim();
      // Removed constructorArgs input field

      if (!abiString || !bytecode) {
        resultBox.innerHTML = '<div class="alert alert-warning mt-2">Please enter both ABI and Bytecode.</div>';
        spinner.style.display = 'none';
        loader.style.display = 'none';
        return;
      }

      let abi;
      try {
        abi = JSON.parse(abiString);
        if (!Array.isArray(abi)) {
            throw new Error("ABI must be a JSON array.");
        }
      } catch (e) {
        resultBox.innerHTML = `<div class="alert alert-danger mt-2">Invalid ABI: ${e.message}</div>`;
        spinner.style.display = 'none';
        loader.style.display = 'none';
        return;
      }

      try {
        let contractAddressOrError;
        if (radioMetaMask.checked && metaMaskConnectedAccount) {
            // MetaMask deployment
            const contract = new web3MetaMask.eth.Contract(abi);
            // No arguments passed to constructor
            const deployTx = contract.deploy({
                data: bytecode,
                arguments: [] // Pass empty array for arguments
            });
            const gasEstimate = await deployTx.estimateGas({ from: metaMaskConnectedAccount });

            const receipt = await deployTx.send({
                    from: metaMaskConnectedAccount,
                    gas: gasEstimate + 50000 // Add a buffer
                });
            contractAddressOrError = receipt.options.address; // Get deployed address from receipt
            resultBox.innerHTML = `<div class="alert alert-success mt-2">MetaMask Contract Deployed: ${contractAddressOrError}</div>`;
        } else {
            // Check if backend wallet is actually connected before attempting backend deploy
            if (!backendWalletConnectedAddress) {
                resultBox.innerHTML = '<div class="alert alert-warning mt-2">No backend wallet connected. Please connect one or switch to MetaMask.</div>';
                spinner.style.display = 'none';
                loader.style.display = 'none';
                return;
            }
            // Backend private key deployment (original flow)
            const res = await fetch('/deploy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ abi, bytecode }) // No constructor_args passed
            });
            const data = await res.json();
            if (data.contract_address) {
                contractAddressOrError = data.contract_address;
                resultBox.innerHTML = `<div class="alert alert-success mt-2">Backend Contract Deployed: ${contractAddressOrError}</div>`;
            } else {
                resultBox.innerHTML = '‚ùå ' + (data.error || 'Unknown error during backend deployment.');
            }
        }
      } catch (e) {
        resultBox.innerHTML = '‚ùå Error deploying contract: ' + e.message;
      }
      spinner.style.display = 'none';
      loader.style.display = 'none';
    }

    // --- Interact with Contract Logic ---
    async function interact() {
      const spinner = document.getElementById('interactSpinner');
      const loader = document.getElementById('interactLoader');
      const resultBox = document.getElementById('interactResult');
      spinner.style.display = 'inline-block';
      loader.style.display = 'block';
      resultBox.innerText = ''; // Clear previous output

      const abiString = document.getElementById('interactAbi').value.trim();
      const contract_address = document.getElementById('contractAddress').value.trim();
      const method = document.getElementById('methodName').value.trim();
      const argsString = document.getElementById('methodArgs').value.trim();

      if (!abiString || !contract_address || !method) {
        resultBox.innerHTML = '<div class="alert alert-warning mt-2">Please fill in ABI, Address, and Method.</div>';
        spinner.style.display = 'none';
        loader.style.display = 'none';
        return;
      }

      let abi;
      try {
        abi = JSON.parse(abiString);
        if (!Array.isArray(abi)) {
            throw new Error("ABI must be a JSON array.");
        }
      } catch (e) {
        resultBox.innerHTML = `<div class="alert alert-danger mt-2">Invalid ABI: ${e.message}</div>`;
        spinner.style.display = 'none';
        loader.style.display = 'none';
        return;
      }

      let args = [];
      if (argsString) {
          try {
              args = JSON.parse(`[${argsString}]`);
          }
          catch (e) {
              args = argsString.split(',').map(arg => arg.trim());
              args = args.map(arg => {
                  if (!isNaN(parseFloat(arg)) && isFinite(arg)) {
                      return parseFloat(arg);
                  }
                  return arg;
              });
          }
      }

      try {
        let result;
        // Check method's stateMutability to determine if it's a transaction (needs signing)
        const methodAbiEntry = abi.find(item => item.name === method && item.type === 'function');
        const isTransaction = methodAbiEntry && methodAbiEntry.stateMutability && !['view', 'pure'].includes(methodAbiEntry.stateMutability);

        if (radioMetaMask.checked && metaMaskConnectedAccount) {
            // MetaMask interaction
            const contract = new web3MetaMask.eth.Contract(abi, contract_address);
            if (isTransaction) {
                // Transaction method
                const tx = contract.methods[method](...args);
                const gasEstimate = await tx.estimateGas({ from: metaMaskConnectedAccount });
                const receipt = await tx.send({
                    from: metaMaskConnectedAccount,
                    gas: gasEstimate + 50000 // Add a buffer
                });
                result = `<div class="alert alert-success mt-2">MetaMask Transaction Sent: <code>${receipt.transactionHash}</code>. Status: ${receipt.status === true ? 'Success' : 'Failed'}</div>`;
            } else {
                // Read-only method (call)
                const callResult = await contract.methods[method](...args).call();
                if (typeof callResult === 'object' && callResult !== null) {
                    result = `<div class="alert alert-info mt-2"><pre><code>${JSON.stringify(callResult, null, 2)}</code></pre></div>`;
                } else {
                    result = `<div class="alert alert-info mt-2">Result: <code>${callResult}</code></div>`;
                }
            }
        } else {
            // Check if backend wallet is actually connected before attempting backend interaction
            if (!backendWalletConnectedAddress) {
                resultBox.innerHTML = '<div class="alert alert-warning mt-2">No backend wallet connected. Please connect one or switch to MetaMask.</div>';
                spinner.style.display = 'none';
                loader.style.display = 'none';
                return;
            }
            // Backend private key interaction (original flow)
            const res = await fetch('/interact', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ abi, contract_address, method, args })
            });
            const data = await res.json();
            if (data.hasOwnProperty('result')) {
                if (isTransaction) {
                    result = `<div class="alert alert-success mt-2">${data.result}</div>`;
                } else {
                    if (typeof data.result === 'object' && data.result !== null) {
                        result = `<div class="alert alert-info mt-2"><pre><code>${JSON.stringify(data.result, null, 2)}</code></pre></div>`;
                    } else {
                        result = `<div class="alert alert-info mt-2">Result: <code>${data.result}</code></div>`;
                    }
                }
            } else {
                result = `<div class="alert alert-danger mt-2">‚ùå ${data.error || 'Unknown error during backend interaction.'}</div>`;
            }
        }

        // Display result
        resultBox.innerHTML = result;

      } catch (e) {
        resultBox.innerHTML = `<div class="alert alert-danger mt-2">‚ùå Error calling contract method: ${e.message}</div>`;
      } finally {
        spinner.style.display = 'none';
        loader.style.display = 'none';
      }
    }

    // --- BlockDAG Visualization Logic ---
    async function loadBlockDAG() {
      try {
        const res = await fetch('/blockdag');
        const blocks = await res.json();
        const nodes = [], edges = [];
        blocks.forEach(b => {
          nodes.push({ id: b.id, label: `${b.id}\n${b.tx_count} txs\n${b.producer}`, shape: 'box' });
          b.parents.forEach(p => edges.push({ from: p, to: b.id }));
        });
        new vis.Network(document.getElementById('blockdagGraph'), {
          nodes: new vis.DataSet(nodes),
          edges: new vis.DataSet(edges)
        }, {
          layout: { hierarchical: false },
          nodes: { color: '#58a6ff', font: { color: 'white' } },
          edges: { color: '#aaa', arrows: 'to' },
          physics: { enabled: true }
        });
      } catch (e) {
        console.error("Error loading BlockDAG:", e);
        document.getElementById('blockdagGraph').innerText = '‚ùå Error loading BlockDAG visualization.';
      }
    }

    // New function to initialize MetaMask state on load
    async function initMetaMaskState() {
        if (typeof window.ethereum !== 'undefined') {
            try {
                // eth_accounts returns an array of addresses connected to the site
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    web3MetaMask = new Web3(window.ethereum); // Initialize web3MetaMask
                    updateMetaMaskInternalState(accounts); // This will update metaMaskConnectedAccount and call updateWalletRadioButtons
                } else {
                    updateMetaMaskInternalState([]); // Call with empty array to clear state if no accounts
                }
            } catch (error) {
                console.error("Error checking initial MetaMask accounts:", error);
                updateMetaMaskInternalState([]); // Ensure state is cleared on error
            }
        } else {
            updateMetaMaskInternalState([]); // No window.ethereum, so clear MetaMask state
        }
    }

    // Function to attempt automatic backend wallet reconnection on load
    async function autoConnectBackendWallet() {
        const storedPrivateKey = localStorage.getItem('backendPrivateKey');
        const storedNodeUrl = localStorage.getItem('backendNodeUrl');

        if (storedPrivateKey && storedNodeUrl) {
            walletConnectMessage.innerHTML = '<div class="alert alert-info mt-2">Attempting to reconnect backend wallet automatically...</div>';
            try {
                const res = await fetch('/set_wallet_config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ private_key: storedPrivateKey, node_url: storedNodeUrl })
                });
                const data = await res.json();

                if (data.status === 'success') {
                    backendWalletConnectedAddress = data.address;
                    console.log("Backend wallet reconnected automatically.");
                    walletConnectMessage.innerHTML = '<div class="alert alert-success mt-2">Backend wallet reconnected automatically.</div>';
                } else {
                    console.error("Auto-reconnection failed:", data.message);
                    walletConnectMessage.innerHTML = `<div class="alert alert-danger mt-2">Auto-reconnection failed: ${data.message}</div>`;
                    // Clear stored credentials if auto-reconnect fails
                    localStorage.removeItem('backendPrivateKey');
                    localStorage.removeItem('backendNodeUrl');
                    backendWalletConnectedAddress = null; // Ensure state is reset
                }
            } catch (error) {
                console.error("Network error during auto-reconnection:", error);
                walletConnectMessage.innerHTML = `<div class="alert alert-danger mt-2">Network error during auto-reconnection: ${error.message}</div>`;
                // Clear stored credentials on network error
                localStorage.removeItem('backendPrivateKey');
                localStorage.removeItem('backendNodeUrl');
                backendWalletConnectedAddress = null; // Ensure state is reset
            }
        }
    }

    // NEW: Contract Verification Functions
    async function verifyContract() {
      const contractAddress = document.getElementById('verifyContractAddressInput').value.trim();
      const sourceCode = document.getElementById('verifySourceCodeInput').value.trim();
      const contractName = document.getElementById('verifyContractNameInput').value.trim();
      const compilerVersion = document.getElementById('verifyCompilerVersionInput').value.trim();
      const optimizationUsed = document.getElementById('verifyOptimizationUsed').checked;
      const runs = parseInt(document.getElementById('verifyRunsInput').value, 10);

      const verifySpinner = document.getElementById('verifySpinner');
      const verifyLoader = document.getElementById('verifyLoader');
      const verifyOutput = document.getElementById('verifyOutput');

      if (!contractAddress || !sourceCode || !contractName || !compilerVersion) {
        verifyOutput.innerHTML = '<div class="alert alert-warning mt-2">Please fill in all required fields: Contract Address, Source Code, Contract Name, and Compiler Version.</div>';
        verifyOutput.style.display = 'block';
        return;
      }

      verifySpinner.style.display = 'inline-block';
      verifyLoader.style.display = 'block';
      verifyOutput.style.display = 'none'; // Hide previous output

      try {
        const response = await fetch('/verify_contract', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contract_address: contractAddress,
            source_code: sourceCode,
            contract_name: contractName,
            compiler_version: compilerVersion,
            optimization_used: optimizationUsed,
            runs: runs
          })
        });
        const data = await response.json();

        if (data.status === 'success') {
          verifyOutput.innerHTML = `<div class="alert alert-success mt-2">Verification Status: ${data.message}</div>`;
        } else if (data.status === 'error') {
          verifyOutput.innerHTML = `<div class="alert alert-danger mt-2">Verification Error: ${data.message}</div>`;
        }
        verifyOutput.style.display = 'block';
      } catch (error) {
        console.error('Verification Error:', error);
        verifyOutput.innerHTML = `<div class="alert alert-danger mt-2">Network error during verification: ${error.message}</div>`;
        verifyOutput.style.display = 'block';
      } finally {
        verifySpinner.style.display = 'none';
        verifyLoader.style.display = 'none';
      }
    }


    window.onload = async () => { // Make onload async
        loadBlockDAG();
        // Ensure private key and derived address inputs are empty on load
        privateKeyInput.value = '';
        walletAddressInput.value = '';
        nodeUrlInput.value = 'http://127.0.0.1:8545'; // Set default node URL

        // Load stored values if any, and set them in the input fields
        const storedPrivateKey = localStorage.getItem('backendPrivateKey');
        const storedNodeUrl = localStorage.getItem('backendNodeUrl');
        if (storedPrivateKey) {
            privateKeyInput.value = storedPrivateKey;
            // Attempt to derive address locally for display
            try {
                const account = web3.eth.accounts.privateKeyToAccount(storedPrivateKey);
                walletAddressInput.value = account.address;
            } catch (e) {
                console.error("Error deriving address from stored private key:", e);
                walletAddressInput.value = 'Invalid Stored Key';
            }
        }
        if (storedNodeUrl) {
            nodeUrlInput.value = storedNodeUrl;
        }

        // Call initial setup functions in order
        // Auto-connect backend first as it might be synchronous or quicker to get status
        await autoConnectBackendWallet();
        // Then initialize MetaMask state
        await initMetaMaskState();

        // NEW: Event listener for optimizationUsed checkbox (moved here for DOMContentLoaded)
        document.getElementById('verifyOptimizationUsed').addEventListener('change', function() {
            const verifyRunsGroup = document.getElementById('verifyRunsGroup');
            if (this.checked) {
                verifyRunsGroup.style.display = 'block';
            } else {
                verifyRunsGroup.style.display = 'none';
            }
        });

        // NEW: Event listener for verifyContractBtn (moved here for DOMContentLoaded)
        document.getElementById('verifyContractBtn').addEventListener('click', verifyContract);
    };

  </script>
</body>
</html>
